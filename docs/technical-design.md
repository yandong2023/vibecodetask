# VibeCodeTask æŠ€æœ¯æ–¹æ¡ˆ

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 èƒŒæ™¯ä¸é—®é¢˜

å½“å‰ä½¿ç”¨ Claude Code è¿›è¡Œå¼€å‘æ—¶å­˜åœ¨çš„ç—›ç‚¹ï¼š
- **æ—¶é—´åˆ©ç”¨ç‡ä½**ï¼šç”¨æˆ·ç¡è§‰æˆ–ç¦»å¼€æ—¶ï¼ŒClaude Code å¤„äºé—²ç½®çŠ¶æ€
- **ä»»åŠ¡ç®¡ç†åˆ†æ•£**ï¼šéœ€è¦æ‰‹åŠ¨é€ä¸ªä¸‹è¾¾æŒ‡ä»¤ï¼Œæ— æ³•æ‰¹é‡ç®¡ç†
- **é¢åº¦æµªè´¹**ï¼šè®¢é˜…é¢åº¦æ— æ³• 24 å°æ—¶å……åˆ†åˆ©ç”¨
- **æ‰§è¡Œæ•ˆç‡ä½**ï¼šç¼ºä¹ç³»ç»ŸåŒ–çš„ä»»åŠ¡æ‹†è§£å’Œæ‰§è¡Œç­–ç•¥

### 1.2 è§£å†³æ–¹æ¡ˆ

æ„å»ºä¸€ä¸ªè‡ªåŠ¨åŒ–ä»»åŠ¡ç®¡ç†ç³»ç»Ÿï¼Œå®ç°ï¼š
- ä»»åŠ¡é˜Ÿåˆ—è‡ªåŠ¨åŒ–ç®¡ç†
- åŸºäºä½¿ç”¨é¢åº¦çš„æ™ºèƒ½è°ƒåº¦
- æç¤ºè¯ä¼˜åŒ–æé«˜æ‰§è¡Œæ•ˆç‡
- 24 å°æ—¶æ— äººå€¼å®ˆè¿è¡Œ

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ç”¨æˆ·ç•Œé¢å±‚                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ CLI ç•Œé¢  â”‚  â”‚ é…ç½®æ–‡ä»¶  â”‚  â”‚ Web UI   â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     åº”ç”¨æœåŠ¡å±‚                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ä»»åŠ¡ç®¡ç†å™¨    â”‚  â”‚ è°ƒåº¦å¼•æ“      â”‚  â”‚ ç›‘æ§æœåŠ¡      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ ¸å¿ƒå¼•æ“å±‚                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æç¤ºè¯ä¼˜åŒ–å™¨  â”‚  â”‚ ä»»åŠ¡æ‰§è¡Œå™¨    â”‚  â”‚ é¢åº¦ç›‘æ§å™¨    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     åŸºç¡€è®¾æ–½å±‚                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Claude Code  â”‚  â”‚ æ–‡ä»¶ç³»ç»Ÿ      â”‚  â”‚ æ—¥å¿—ç³»ç»Ÿ      â”‚ â”‚
â”‚  â”‚     CLI      â”‚  â”‚               â”‚  â”‚               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒæ¨¡å—è®¾è®¡

#### 2.2.1 ä»»åŠ¡ç®¡ç†å™¨ (Task Manager)

**èŒè´£**ï¼š
- åŠ è½½å’Œè§£æä»»åŠ¡é…ç½®
- ç»´æŠ¤ä»»åŠ¡é˜Ÿåˆ—
- ç®¡ç†ä»»åŠ¡çŠ¶æ€å’Œä¾èµ–å…³ç³»

**æ ¸å¿ƒæ•°æ®ç»“æ„**ï¼š
```javascript
class Task {
  id: string
  name: string
  priority: number
  status: 'pending' | 'running' | 'completed' | 'failed'
  requirements: string
  dependencies: string[]
  result: any
  createdAt: Date
  startedAt: Date
  completedAt: Date
}

class TaskQueue {
  tasks: Map<string, Task>
  pendingQueue: PriorityQueue<Task>
  runningTasks: Set<string>
  completedTasks: Set<string>
}
```

#### 2.2.2 è°ƒåº¦å¼•æ“ (Scheduler)

**èŒè´£**ï¼š
- æ ¹æ®ä¼˜å…ˆçº§å’Œä¾èµ–å…³ç³»è°ƒåº¦ä»»åŠ¡
- ç›‘æ§ Claude Code ä½¿ç”¨é¢åº¦
- å®ç°ä¸åŒçš„è°ƒåº¦ç­–ç•¥

**è°ƒåº¦ç­–ç•¥**ï¼š
1. **æ™ºèƒ½è°ƒåº¦**ï¼šåŸºäºé¢åº¦ã€ä¼˜å…ˆçº§ã€é¢„ä¼°æ—¶é—´ç»¼åˆå†³ç­–
2. **é¡ºåºè°ƒåº¦**ï¼šæŒ‰é…ç½®é¡ºåºæ‰§è¡Œ
3. **æ‰‹åŠ¨è°ƒåº¦**ï¼šç”¨æˆ·æ‰‹åŠ¨è§¦å‘

**æ ¸å¿ƒç®—æ³•**ï¼š
```javascript
function scheduleNext() {
  // 1. æ£€æŸ¥å½“å‰è¿è¡Œä»»åŠ¡æ•°
  if (runningTasks.size >= maxConcurrent) return
  
  // 2. è·å–å¯ç”¨é¢åº¦
  const usage = await getClaudeUsage()
  if (!hasAvailableQuota(usage)) return
  
  // 3. é€‰æ‹©ä¸‹ä¸€ä¸ªä»»åŠ¡
  const task = selectNextTask(pendingQueue, usage)
  if (!task) return
  
  // 4. æ£€æŸ¥ä¾èµ–
  if (!checkDependencies(task)) return
  
  // 5. æ‰§è¡Œä»»åŠ¡
  executeTask(task)
}
```

#### 2.2.3 æç¤ºè¯ä¼˜åŒ–å™¨ (Prompt Optimizer)

**èŒè´£**ï¼š
- åˆ†æåŸå§‹éœ€æ±‚
- ç”Ÿæˆç»“æ„åŒ–æŠ€æœ¯æ–¹æ¡ˆ
- åˆ›å»ºç»†ç²’åº¦ä»»åŠ¡æ¸…å•
- ä¼˜åŒ–æç¤ºè¯æ ¼å¼

**ä¼˜åŒ–æµç¨‹**ï¼š
```
åŸå§‹éœ€æ±‚ â†’ éœ€æ±‚åˆ†æ â†’ æŠ€æœ¯æ–¹æ¡ˆ â†’ ä»»åŠ¡æ‹†è§£ â†’ ä¼˜åŒ–æç¤ºè¯
```

**æç¤ºè¯æ¨¡æ¿**ï¼š
```markdown
## ä»»åŠ¡ç›®æ ‡
[æ˜ç¡®çš„ä»»åŠ¡ç›®æ ‡]

## æŠ€æœ¯æ–¹æ¡ˆ
[è¯¦ç»†çš„å®ç°æ–¹æ¡ˆ]

## ä»»åŠ¡æ¸…å•
- [ ] å­ä»»åŠ¡1
- [ ] å­ä»»åŠ¡2
- [ ] å­ä»»åŠ¡3

## æ‰§è¡Œè¦æ±‚
1. æŒ‰é¡ºåºå®Œæˆæ¯ä¸ªå­ä»»åŠ¡
2. å®Œæˆä¸€é¡¹åæ ‡è®°ä¸ºå·²å®Œæˆ
3. é‡åˆ°é—®é¢˜è®°å½•å¹¶ç»§ç»­ä¸‹ä¸€é¡¹
4. ç”Ÿæˆæ‰§è¡ŒæŠ¥å‘Š

## è¾“å‡ºæ ¼å¼
è¯·ä»¥ç»“æ„åŒ–æ ¼å¼è¾“å‡ºç»“æœ...
```

#### 2.2.4 é¢åº¦ç›‘æ§å™¨ (Usage Monitor)

**èŒè´£**ï¼š
- è°ƒç”¨ `ccusage blocks --live` è·å–ä½¿ç”¨æƒ…å†µ
- è§£æä½¿ç”¨æ•°æ®
- é¢„æµ‹å‰©ä½™å¯ç”¨æ—¶é—´

**æ•°æ®ç»“æ„**ï¼š
```javascript
interface UsageInfo {
  totalBlocks: number
  usedBlocks: number
  remainingBlocks: number
  resetTime: Date
  estimatedTimeRemaining: number
}
```

#### 2.2.5 ä»»åŠ¡æ‰§è¡Œå™¨ (Task Executor)

**èŒè´£**ï¼š
- è°ƒç”¨ Claude Code CLI
- æ•è·æ‰§è¡Œè¾“å‡º
- å¤„ç†é”™è¯¯å’Œé‡è¯•
- è®°å½•æ‰§è¡Œç»“æœ

**æ‰§è¡Œæµç¨‹**ï¼š
```javascript
async function executeTask(task) {
  // 1. ä¼˜åŒ–æç¤ºè¯
  const prompt = await optimizePrompt(task)
  
  // 2. æ„å»ºå‘½ä»¤
  const command = buildClaudeCommand(prompt)
  
  // 3. æ‰§è¡Œå‘½ä»¤
  const result = await executeCommand(command)
  
  // 4. è§£æç»“æœ
  const parsed = parseResult(result)
  
  // 5. æ›´æ–°ä»»åŠ¡çŠ¶æ€
  updateTaskStatus(task, parsed)
  
  // 6. è®°å½•æ—¥å¿—
  logExecution(task, result)
}
```

## 3. æŠ€æœ¯é€‰å‹

### 3.1 å¼€å‘è¯­è¨€ä¸æ¡†æ¶
- **ä¸»è¯­è¨€**ï¼šNode.js (JavaScript/TypeScript)
- **åŸå› **ï¼š
  - ä¸ Claude Code CLI é›†æˆæ–¹ä¾¿
  - å¼‚æ­¥å¤„ç†èƒ½åŠ›å¼º
  - ç”Ÿæ€ç³»ç»Ÿä¸°å¯Œ

### 3.2 æ ¸å¿ƒä¾èµ–
```json
{
  "dependencies": {
    "node-cron": "^3.0.0",      // å®šæ—¶ä»»åŠ¡
    "commander": "^11.0.0",      // CLI æ¡†æ¶
    "winston": "^3.10.0",        // æ—¥å¿—ç³»ç»Ÿ
    "p-queue": "^7.3.0",         // ä»»åŠ¡é˜Ÿåˆ—
    "chalk": "^5.3.0",           // ç»ˆç«¯ç¾åŒ–
    "inquirer": "^9.2.0",        // äº¤äº’å¼ CLI
    "yaml": "^2.3.0"             // YAML é…ç½®è§£æ
  }
}
```

### 3.3 æ•°æ®å­˜å‚¨
- **é…ç½®æ–‡ä»¶**ï¼šJSON/YAML æ ¼å¼
- **ä»»åŠ¡çŠ¶æ€**ï¼šå†…å­˜ + æ–‡ä»¶æŒä¹…åŒ–
- **æ—¥å¿—**ï¼šæ–‡æœ¬æ–‡ä»¶ + è½®è½¬

## 4. å…³é”®åŠŸèƒ½å®ç°

### 4.1 é¡¹ç›®åˆå§‹åŒ–ä»£ç 

**package.json**:
```json
{
  "name": "vibecodetask",
  "version": "1.0.0",
  "description": "Claude Code è‡ªåŠ¨ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ",
  "main": "src/index.js",
  "bin": {
    "vibecodetask": "./bin/vct",
    "vct": "./bin/vct"
  },
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest",
    "lint": "eslint src/",
    "build": "pkg . --out-path dist/"
  },
  "dependencies": {
    "commander": "^11.0.0",
    "node-cron": "^3.0.2",
    "winston": "^3.10.0",
    "p-queue": "^7.4.1",
    "chalk": "^5.3.0",
    "inquirer": "^9.2.12",
    "yaml": "^2.3.4"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.0.1",
    "eslint": "^8.50.0"
  },
  "keywords": ["claude", "ai", "automation", "task-management"],
  "author": "Your Name",
  "license": "MIT"
}
```

### 4.2 Claude Code é›†æˆ

```javascript
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

class ClaudeCodeClient {
  async getUsage() {
    const { stdout } = await execPromise('ccusage blocks --live');
    return this.parseUsage(stdout);
  }
  
  async executePrompt(prompt, options = {}) {
    const command = this.buildCommand(prompt, options);
    const { stdout, stderr } = await execPromise(command);
    return { output: stdout, error: stderr };
  }
  
  buildCommand(prompt, options) {
    // æ„å»º Claude Code å‘½ä»¤
    let cmd = 'claude';
    if (options.model) cmd += ` --model ${options.model}`;
    if (options.maxTokens) cmd += ` --max-tokens ${options.maxTokens}`;
    cmd += ` "${prompt.replace(/"/g, '\\"')}"`;
    return cmd;
  }
  
  parseUsage(output) {
    // è§£æ ccusage blocks --live è¾“å‡º
    const lines = output.split('\n');
    const usage = {};
    lines.forEach(line => {
      if (line.includes('Total blocks')) {
        usage.total = parseInt(line.match(/\d+/)[0]);
      }
      if (line.includes('Used blocks')) {
        usage.used = parseInt(line.match(/\d+/)[0]);
      }
      if (line.includes('Reset time')) {
        usage.resetTime = new Date(line.split(':').slice(1).join(':').trim());
      }
    });
    usage.remaining = usage.total - usage.used;
    return usage;
  }
}
```

### 4.2 ä»»åŠ¡è°ƒåº¦å®ç°

```javascript
const cron = require('node-cron');
const PQueue = require('p-queue').default;

class TaskScheduler {
  constructor() {
    this.queue = new PQueue({ concurrency: 1 });
    this.tasks = new Map();
    this.cronJob = null;
  }
  
  start() {
    // æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    this.cronJob = cron.schedule('*/5 * * * *', async () => {
      await this.checkAndSchedule();
    });
  }
  
  async checkAndSchedule() {
    // 1. æ£€æŸ¥ä½¿ç”¨é¢åº¦
    const usage = await this.claudeClient.getUsage();
    if (usage.remaining < MIN_BLOCKS_REQUIRED) {
      console.log('é¢åº¦ä¸è¶³ï¼Œç­‰å¾…é‡ç½®...');
      return;
    }
    
    // 2. è·å–å¾…æ‰§è¡Œä»»åŠ¡
    const pendingTasks = this.getPendingTasks();
    if (pendingTasks.length === 0) {
      console.log('æ²¡æœ‰å¾…æ‰§è¡Œä»»åŠ¡');
      return;
    }
    
    // 3. é€‰æ‹©ä»»åŠ¡æ‰§è¡Œ
    const task = this.selectTask(pendingTasks, usage);
    if (task) {
      await this.executeTask(task);
    }
  }
  
  selectTask(tasks, usage) {
    // æ ¹æ®ä¼˜å…ˆçº§ã€é¢„ä¼°æ—¶é—´ã€é¢åº¦é€‰æ‹©ä»»åŠ¡
    return tasks
      .filter(t => this.canExecute(t, usage))
      .sort((a, b) => a.priority - b.priority)[0];
  }
  
  canExecute(task, usage) {
    // æ£€æŸ¥ä¾èµ–å’Œé¢åº¦
    const depsCompleted = task.dependencies.every(
      depId => this.tasks.get(depId)?.status === 'completed'
    );
    const hasEnoughQuota = usage.remaining >= task.estimatedBlocks;
    return depsCompleted && hasEnoughQuota;
  }
}
```

### 4.3 æç¤ºè¯ä¼˜åŒ–å®ç°

```javascript
const fs = require('fs').promises;
const path = require('path');

class PromptOptimizer {
  constructor() {
    this.templates = new Map();
    this.loadTemplates();
  }

  async loadTemplates() {
    // åŠ è½½æç¤ºè¯æ¨¡æ¿
    const templatesDir = path.join(__dirname, '../templates');
    try {
      const files = await fs.readdir(templatesDir);
      for (const file of files) {
        if (file.endsWith('.yaml')) {
          const content = await fs.readFile(path.join(templatesDir, file), 'utf-8');
          const template = yaml.load(content);
          this.templates.set(template.type, template);
        }
      }
    } catch (error) {
      console.warn('æœªèƒ½åŠ è½½æç¤ºè¯æ¨¡æ¿:', error.message);
    }
  }

  optimize(task) {
    const analysis = this.analyzeRequirements(task.requirements);
    const plan = this.generatePlan(analysis, task.type);
    const checklist = this.createChecklist(plan);
    const template = this.getTemplate(task.type);
    
    return this.buildOptimizedPrompt({
      goal: task.name,
      requirements: analysis,
      plan: plan,
      checklist: checklist,
      template: template,
      context: task.context || {}
    });
  }
  
  analyzeRequirements(requirements) {
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å’Œ NLP æŠ€æœ¯åˆ†æéœ€æ±‚
    return {
      mainGoal: this.extractMainGoal(requirements),
      constraints: this.extractConstraints(requirements),
      expectedOutputs: this.extractOutputs(requirements),
      technologies: this.extractTechnologies(requirements),
      complexity: this.assessComplexity(requirements)
    };
  }

  extractMainGoal(requirements) {
    // æå–ä¸»è¦ç›®æ ‡
    const goalKeywords = ['åˆ›å»º', 'å®ç°', 'æ„å»º', 'å¼€å‘', 'è®¾è®¡', 'ä¼˜åŒ–', 'é‡æ„'];
    const sentences = requirements.split(/[ã€‚.!ï¼]/);
    
    for (const sentence of sentences) {
      for (const keyword of goalKeywords) {
        if (sentence.includes(keyword)) {
          return sentence.trim();
        }
      }
    }
    
    return sentences[0]?.trim() || requirements.substring(0, 100);
  }

  extractConstraints(requirements) {
    // æå–çº¦æŸæ¡ä»¶
    const constraints = [];
    const constraintPatterns = [
      /å¿…é¡»ä½¿ç”¨\s*([^ï¼Œ,ã€‚.]+)/g,
      /ä¸èƒ½ä½¿ç”¨\s*([^ï¼Œ,ã€‚.]+)/g,
      /éœ€è¦æ”¯æŒ\s*([^ï¼Œ,ã€‚.]+)/g,
      /å…¼å®¹\s*([^ï¼Œ,ã€‚.]+)/g
    ];

    constraintPatterns.forEach(pattern => {
      let match;
      while ((match = pattern.exec(requirements)) !== null) {
        constraints.push(match[1].trim());
      }
    });

    return constraints;
  }

  extractTechnologies(requirements) {
    // æå–æŠ€æœ¯æ ˆ
    const techKeywords = [
      'React', 'Vue', 'Angular', 'Node.js', 'Express', 'Next.js',
      'TypeScript', 'JavaScript', 'Python', 'Django', 'Flask',
      'Docker', 'Kubernetes', 'AWS', 'MongoDB', 'PostgreSQL',
      'Redis', 'GraphQL', 'REST API'
    ];

    return techKeywords.filter(tech => 
      requirements.toLowerCase().includes(tech.toLowerCase())
    );
  }

  assessComplexity(requirements) {
    // è¯„ä¼°å¤æ‚åº¦
    const complexityIndicators = {
      simple: ['åˆ›å»º', 'ç”Ÿæˆ', 'æ·»åŠ '],
      medium: ['é‡æ„', 'ä¼˜åŒ–', 'é›†æˆ', 'é…ç½®'],
      complex: ['æ¶æ„', 'ç³»ç»Ÿ', 'å¹³å°', 'æ¡†æ¶']
    };

    for (const [level, indicators] of Object.entries(complexityIndicators)) {
      if (indicators.some(indicator => requirements.includes(indicator))) {
        return level;
      }
    }

    return 'simple';
  }
  
  generatePlan(analysis, taskType = 'development') {
    // æ ¹æ®ä»»åŠ¡ç±»å‹ç”Ÿæˆè®¡åˆ’
    const planGenerators = {
      development: this.generateDevelopmentPlan.bind(this),
      testing: this.generateTestingPlan.bind(this),
      documentation: this.generateDocumentationPlan.bind(this),
      refactoring: this.generateRefactoringPlan.bind(this)
    };

    const generator = planGenerators[taskType] || planGenerators.development;
    return generator(analysis);
  }

  generateDevelopmentPlan(analysis) {
    const steps = [];
    
    // æ ¹æ®å¤æ‚åº¦ç”Ÿæˆä¸åŒçš„æ­¥éª¤
    switch (analysis.complexity) {
      case 'simple':
        steps.push(
          { description: 'åˆ†æéœ€æ±‚å’ŒæŠ€æœ¯é€‰å‹', validation: 'ç¡®è®¤æŠ€æœ¯æ ˆ' },
          { description: 'åˆ›å»ºé¡¹ç›®ç»“æ„', validation: 'éªŒè¯æ–‡ä»¶ç»“æ„' },
          { description: 'å®ç°æ ¸å¿ƒåŠŸèƒ½', validation: 'åŠŸèƒ½æµ‹è¯•' },
          { description: 'å®Œå–„é”™è¯¯å¤„ç†', validation: 'å¼‚å¸¸æµ‹è¯•' }
        );
        break;
      
      case 'complex':
        steps.push(
          { description: 'éœ€æ±‚åˆ†æå’Œæ¶æ„è®¾è®¡', validation: 'æ¶æ„è¯„å®¡' },
          { description: 'åˆ›å»ºé¡¹ç›®è„šæ‰‹æ¶', validation: 'ç¯å¢ƒéªŒè¯' },
          { description: 'å®ç°æ ¸å¿ƒæ¨¡å—', validation: 'å•å…ƒæµ‹è¯•' },
          { description: 'é›†æˆå„æ¨¡å—', validation: 'é›†æˆæµ‹è¯•' },
          { description: 'æ€§èƒ½ä¼˜åŒ–', validation: 'æ€§èƒ½æµ‹è¯•' },
          { description: 'æ–‡æ¡£å’Œéƒ¨ç½²', validation: 'éƒ¨ç½²éªŒè¯' }
        );
        break;
      
      default: // medium
        steps.push(
          { description: 'åˆ†æéœ€æ±‚å’Œè®¾è®¡æ–¹æ¡ˆ', validation: 'æ–¹æ¡ˆç¡®è®¤' },
          { description: 'æ­å»ºå¼€å‘ç¯å¢ƒ', validation: 'ç¯å¢ƒæµ‹è¯•' },
          { description: 'å®ç°ä¸»è¦åŠŸèƒ½', validation: 'åŠŸèƒ½éªŒè¯' },
          { description: 'æ·»åŠ æµ‹è¯•ç”¨ä¾‹', validation: 'æµ‹è¯•é€šè¿‡' },
          { description: 'ä»£ç ä¼˜åŒ–å’Œé‡æ„', validation: 'ä»£ç å®¡æŸ¥' }
        );
    }

    return {
      approach: this.determineApproach(analysis),
      steps: steps,
      considerations: this.identifyConsiderations(analysis)
    };
  }

  generateTestingPlan(analysis) {
    return {
      approach: 'é‡‡ç”¨ TDD æ–¹æ³•ç¼–å†™å…¨é¢çš„æµ‹è¯•ç”¨ä¾‹',
      steps: [
        { description: 'åˆ†ææµ‹è¯•éœ€æ±‚', validation: 'æµ‹è¯•è®¡åˆ’ç¡®è®¤' },
        { description: 'è®¾è®¡æµ‹è¯•ç”¨ä¾‹', validation: 'ç”¨ä¾‹è¯„å®¡' },
        { description: 'ç¼–å†™å•å…ƒæµ‹è¯•', validation: 'å•å…ƒæµ‹è¯•é€šè¿‡' },
        { description: 'ç¼–å†™é›†æˆæµ‹è¯•', validation: 'é›†æˆæµ‹è¯•é€šè¿‡' },
        { description: 'ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š', validation: 'è¦†ç›–ç‡è¾¾æ ‡' }
      ],
      considerations: ['æµ‹è¯•è¦†ç›–ç‡', 'è¾¹ç•Œæ¡ä»¶', 'å¼‚å¸¸å¤„ç†', 'æ€§èƒ½æµ‹è¯•']
    };
  }

  getTemplate(taskType) {
    return this.templates.get(taskType) || this.templates.get('default') || {
      structure: 'basic'
    };
  }
  
  createChecklist(plan) {
    // åˆ›å»ºè¯¦ç»†çš„ä»»åŠ¡æ¸…å•
    return plan.steps.map((step, index) => ({
      id: `step-${index + 1}`,
      description: step.description,
      validation: step.validation,
      completed: false,
      estimatedTime: this.estimateStepTime(step.description)
    }));
  }

  estimateStepTime(description) {
    // åŸºäºä»»åŠ¡æè¿°ä¼°ç®—æ—¶é—´
    const timeIndicators = {
      'åˆ†æ|è®¾è®¡|è§„åˆ’': 30,
      'åˆ›å»º|æ­å»º|åˆå§‹åŒ–': 15,
      'å®ç°|å¼€å‘|ç¼–å†™': 60,
      'æµ‹è¯•|éªŒè¯|æ£€æŸ¥': 30,
      'ä¼˜åŒ–|é‡æ„|æ”¹è¿›': 45,
      'éƒ¨ç½²|å‘å¸ƒ|é…ç½®': 20
    };

    for (const [pattern, minutes] of Object.entries(timeIndicators)) {
      if (new RegExp(pattern).test(description)) {
        return `${minutes}m`;
      }
    }

    return '30m';
  }
  
  buildOptimizedPrompt(data) {
    const { goal, requirements, plan, checklist, template, context } = data;
    
    // æ„å»ºä¸Šä¸‹æ–‡ä¿¡æ¯
    let contextInfo = '';
    if (context.workspace) {
      contextInfo += `\nå·¥ä½œç›®å½•: ${context.workspace}`;
    }
    if (context.files && context.files.length > 0) {
      contextInfo += `\nç›¸å…³æ–‡ä»¶: ${context.files.join(', ')}`;
    }

    return `# ğŸ¯ ä»»åŠ¡ï¼š${goal}

## ğŸ“‹ éœ€æ±‚åˆ†æ
**ä¸»è¦ç›®æ ‡**: ${requirements.mainGoal}
**æŠ€æœ¯æ ˆ**: ${requirements.technologies.join(', ') || 'æ ¹æ®éœ€æ±‚é€‰æ‹©'}
**å¤æ‚åº¦**: ${requirements.complexity}
${requirements.constraints.length > 0 ? `**çº¦æŸæ¡ä»¶**: ${requirements.constraints.join(', ')}` : ''}
${contextInfo}

## ğŸ”§ æŠ€æœ¯æ–¹æ¡ˆ
${plan.approach}

### å…³é”®è€ƒè™‘ç‚¹
${plan.considerations.map(c => `- ${c}`).join('\n')}

## ğŸ“ æ‰§è¡Œæ­¥éª¤
${plan.steps.map((s, i) => `### ${i + 1}. ${s.description}
- **éªŒè¯æ ‡å‡†**: ${s.validation}
- **é¢„è®¡æ—¶é—´**: ${this.estimateStepTime(s.description)}
`).join('\n')}

## âœ… ä»»åŠ¡æ¸…å•
${checklist.map(item => `- [ ] ${item.description} (${item.estimatedTime})`).join('\n')}

## ğŸ“– æ‰§è¡Œè¦æ±‚
1. **åˆ†æ­¥æ‰§è¡Œ**: ä¸¥æ ¼æŒ‰ç…§æ­¥éª¤é¡ºåºæ‰§è¡Œ
2. **è¿›åº¦æŠ¥å‘Š**: æ¯å®Œæˆä¸€æ­¥ï¼Œè¾“å‡º "âœ… å·²å®Œæˆï¼š{æ­¥éª¤æè¿°}"
3. **é”™è¯¯å¤„ç†**: é‡åˆ°é”™è¯¯æ—¶è®°å½•è¯¦ç»†ä¿¡æ¯ï¼Œå°è¯•è§£å†³åç»§ç»­
4. **ä»£ç è§„èŒƒ**: éµå¾ªæœ€ä½³å®è·µå’Œç¼–ç è§„èŒƒ
5. **æµ‹è¯•éªŒè¯**: æ¯ä¸ªåŠŸèƒ½å®Œæˆåè¿›è¡Œç›¸åº”æµ‹è¯•
6. **æ–‡æ¡£æ›´æ–°**: æ›´æ–°ç›¸å…³æ–‡æ¡£å’Œæ³¨é‡Š

## ğŸª è¾“å‡ºæ ¼å¼
è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºç»“æœï¼š

\`\`\`
## æ‰§è¡Œæ‘˜è¦
- ä»»åŠ¡çŠ¶æ€: [å®Œæˆ/éƒ¨åˆ†å®Œæˆ/å¤±è´¥]
- å®Œæˆæ­¥éª¤: X/Y
- è€—æ—¶: XXåˆ†é’Ÿ

## ä¸»è¦æˆæœ
- åˆ›å»ºçš„æ–‡ä»¶: [æ–‡ä»¶åˆ—è¡¨]
- å®ç°çš„åŠŸèƒ½: [åŠŸèƒ½åˆ—è¡¨]
- è§£å†³çš„é—®é¢˜: [é—®é¢˜åˆ—è¡¨]

## é‡åˆ°çš„é—®é¢˜
[å¦‚æœ‰é—®é¢˜ï¼Œè¯¦ç»†æè¿°]

## åç»­å»ºè®®
[ä¼˜åŒ–å»ºè®®æˆ–ä¸‹ä¸€æ­¥å·¥ä½œ]
\`\`\`

ğŸš€ **ç°åœ¨å¼€å§‹æ‰§è¡Œä»»åŠ¡...**`;
  }
}

module.exports = PromptOptimizer;
```

## 5. éƒ¨ç½²ä¸è¿ç»´

### 5.1 éƒ¨ç½²æ–¹å¼

1. **æœ¬åœ°éƒ¨ç½²**
   ```bash
   git clone <repository>
   npm install
   npm run build
   npm start
   ```

2. **Docker éƒ¨ç½²**
   ```dockerfile
   FROM node:18-alpine
   WORKDIR /app
   COPY package*.json ./
   RUN npm ci --only=production
   COPY . .
   CMD ["npm", "start"]
   ```

3. **ç³»ç»ŸæœåŠ¡**
   ```bash
   # ä½¿ç”¨ systemd
   sudo cp vibecodetask.service /etc/systemd/system/
   sudo systemctl enable vibecodetask
   sudo systemctl start vibecodetask
   ```

### 5.2 ç›‘æ§ä¸æ—¥å¿—

- **æ—¥å¿—çº§åˆ«**ï¼šERROR, WARN, INFO, DEBUG
- **æ—¥å¿—è½®è½¬**ï¼šæ¯æ—¥è½®è½¬ï¼Œä¿ç•™ 30 å¤©
- **ç›‘æ§æŒ‡æ ‡**ï¼š
  - ä»»åŠ¡æˆåŠŸç‡
  - å¹³å‡æ‰§è¡Œæ—¶é—´
  - é¢åº¦ä½¿ç”¨ç‡
  - ç³»ç»Ÿèµ„æºå ç”¨

### 5.3 é”™è¯¯å¤„ç†

1. **é‡è¯•æœºåˆ¶**ï¼šå¤±è´¥ä»»åŠ¡è‡ªåŠ¨é‡è¯• 3 æ¬¡
2. **é™çº§ç­–ç•¥**ï¼šé¢åº¦ä¸è¶³æ—¶å»¶è¿Ÿæ‰§è¡Œ
3. **å‘Šè­¦é€šçŸ¥**ï¼šå…³é”®é”™è¯¯å‘é€é€šçŸ¥
4. **æ•…éšœæ¢å¤**ï¼šå´©æºƒåè‡ªåŠ¨æ¢å¤ä»»åŠ¡çŠ¶æ€

### 4.4 å®Œæ•´çš„ä»»åŠ¡ç®¡ç†å™¨å®ç°

```javascript
// src/core/TaskManager.js
const EventEmitter = require('events');
const fs = require('fs').promises;
const path = require('path');

class TaskManager extends EventEmitter {
  constructor(options = {}) {
    super();
    this.configFile = options.configFile || 'tasks.json';
    this.tasks = new Map();
    this.runningTasks = new Set();
    this.completedTasks = new Set();
    this.maxConcurrent = options.maxConcurrent || 1;
    this.autosave = options.autosave !== false;
  }

  async initialize() {
    await this.loadTasks();
    this.emit('initialized');
  }

  async loadTasks() {
    try {
      if (await this.fileExists(this.configFile)) {
        const data = await fs.readFile(this.configFile, 'utf-8');
        const config = JSON.parse(data);
        
        for (const taskData of config.tasks || []) {
          const task = new Task(taskData);
          this.tasks.set(task.id, task);
        }
        
        console.log(`å·²åŠ è½½ ${this.tasks.size} ä¸ªä»»åŠ¡`);
      } else {
        console.log('é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤é…ç½®');
        await this.createDefaultConfig();
      }
    } catch (error) {
      console.error('åŠ è½½ä»»åŠ¡å¤±è´¥:', error);
      throw error;
    }
  }

  async saveTasks() {
    const config = {
      tasks: Array.from(this.tasks.values()).map(task => task.toJSON()),
      lastUpdated: new Date().toISOString()
    };

    await fs.writeFile(this.configFile, JSON.stringify(config, null, 2));
  }

  async addTask(taskData) {
    const task = new Task(taskData);
    this.tasks.set(task.id, task);
    
    if (this.autosave) {
      await this.saveTasks();
    }
    
    this.emit('taskAdded', task);
    return task;
  }

  getTask(id) {
    return this.tasks.get(id);
  }

  getAllTasks() {
    return Array.from(this.tasks.values());
  }

  getPendingTasks() {
    return this.getAllTasks()
      .filter(task => task.status === 'pending')
      .sort((a, b) => a.priority - b.priority);
  }

  getNextTask() {
    const pendingTasks = this.getPendingTasks();
    
    for (const task of pendingTasks) {
      if (this.canExecuteTask(task)) {
        return task;
      }
    }
    
    return null;
  }

  canExecuteTask(task) {
    // æ£€æŸ¥å¹¶å‘é™åˆ¶
    if (this.runningTasks.size >= this.maxConcurrent) {
      return false;
    }

    // æ£€æŸ¥ä¾èµ–
    if (task.dependencies && task.dependencies.length > 0) {
      return task.dependencies.every(depId => {
        const depTask = this.tasks.get(depId);
        return depTask && depTask.status === 'completed';
      });
    }

    return true;
  }

  async executeTask(task) {
    if (this.runningTasks.has(task.id)) {
      throw new Error(`ä»»åŠ¡ ${task.id} å·²åœ¨è¿è¡Œä¸­`);
    }

    this.runningTasks.add(task.id);
    task.status = 'running';
    task.startedAt = new Date();

    this.emit('taskStarted', task);

    try {
      const result = await this.runTask(task);
      
      task.status = 'completed';
      task.completedAt = new Date();
      task.result = result;
      
      this.runningTasks.delete(task.id);
      this.completedTasks.add(task.id);
      
      if (this.autosave) {
        await this.saveTasks();
      }
      
      this.emit('taskCompleted', task, result);
      return result;

    } catch (error) {
      task.status = 'failed';
      task.error = error.message;
      task.completedAt = new Date();
      
      this.runningTasks.delete(task.id);
      
      if (this.autosave) {
        await this.saveTasks();
      }
      
      this.emit('taskFailed', task, error);
      throw error;
    }
  }

  async runTask(task) {
    // è¿™é‡Œä¼šè¢«å…·ä½“çš„æ‰§è¡Œå™¨å®ç°è¦†ç›–
    throw new Error('runTask method must be implemented by subclass');
  }

  getStats() {
    const all = this.getAllTasks();
    return {
      total: all.length,
      pending: all.filter(t => t.status === 'pending').length,
      running: all.filter(t => t.status === 'running').length,
      completed: all.filter(t => t.status === 'completed').length,
      failed: all.filter(t => t.status === 'failed').length
    };
  }

  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  async createDefaultConfig() {
    const defaultConfig = {
      tasks: [
        {
          id: 'example-task',
          name: 'ç¤ºä¾‹ä»»åŠ¡',
          priority: 1,
          type: 'development',
          requirements: 'è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ä»»åŠ¡ï¼Œè¯·æ›¿æ¢ä¸ºæ‚¨çš„å®é™…éœ€æ±‚',
          schedule: 'immediate'
        }
      ],
      settings: {
        maxConcurrent: 1,
        checkInterval: 300000,
        retryLimit: 3
      }
    };

    await fs.writeFile(this.configFile, JSON.stringify(defaultConfig, null, 2));
  }
}

// Task ç±»å®šä¹‰
class Task {
  constructor(data) {
    this.id = data.id || this.generateId();
    this.name = data.name;
    this.priority = data.priority || 99;
    this.type = data.type || 'development';
    this.requirements = data.requirements;
    this.status = data.status || 'pending';
    this.dependencies = data.dependencies || [];
    this.schedule = data.schedule || 'immediate';
    this.estimatedTime = data.estimatedTime;
    this.context = data.context || {};
    this.retryCount = 0;
    this.maxRetries = data.maxRetries || 3;
    
    // æ—¶é—´æˆ³
    this.createdAt = data.createdAt ? new Date(data.createdAt) : new Date();
    this.startedAt = data.startedAt ? new Date(data.startedAt) : null;
    this.completedAt = data.completedAt ? new Date(data.completedAt) : null;
    
    // ç»“æœ
    this.result = data.result;
    this.error = data.error;
  }

  generateId() {
    return `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      priority: this.priority,
      type: this.type,
      requirements: this.requirements,
      status: this.status,
      dependencies: this.dependencies,
      schedule: this.schedule,
      estimatedTime: this.estimatedTime,
      context: this.context,
      retryCount: this.retryCount,
      maxRetries: this.maxRetries,
      createdAt: this.createdAt?.toISOString(),
      startedAt: this.startedAt?.toISOString(),
      completedAt: this.completedAt?.toISOString(),
      result: this.result,
      error: this.error
    };
  }

  canRetry() {
    return this.retryCount < this.maxRetries;
  }

  incrementRetry() {
    this.retryCount++;
  }

  getDuration() {
    if (this.startedAt && this.completedAt) {
      return this.completedAt - this.startedAt;
    }
    return null;
  }
}

module.exports = { TaskManager, Task };
```

### 4.5 ä¸»ç¨‹åºå…¥å£

```javascript
// src/index.js
#!/usr/bin/env node

const { Command } = require('commander');
const VibeCodeTask = require('./VibeCodeTask');
const chalk = require('chalk');
const packageJson = require('../package.json');

const program = new Command();

program
  .name('vct')
  .description('Claude Code è‡ªåŠ¨ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ')
  .version(packageJson.version);

program
  .command('init')
  .description('åˆå§‹åŒ–é…ç½®æ–‡ä»¶')
  .action(async () => {
    const vct = new VibeCodeTask();
    await vct.init();
    console.log(chalk.green('âœ… é…ç½®æ–‡ä»¶å·²åˆ›å»º'));
  });

program
  .command('run')
  .description('è¿è¡Œä»»åŠ¡')
  .option('-c, --config <file>', 'é…ç½®æ–‡ä»¶è·¯å¾„', 'tasks.json')
  .option('--once', 'åªè¿è¡Œä¸€æ¬¡')
  .action(async (options) => {
    const vct = new VibeCodeTask(options);
    
    if (options.once) {
      await vct.runOnce();
    } else {
      await vct.start();
    }
  });

program
  .command('add <description>')
  .description('æ·»åŠ æ–°ä»»åŠ¡')
  .option('-p, --priority <number>', 'ä¼˜å…ˆçº§', 5)
  .option('-t, --type <type>', 'ä»»åŠ¡ç±»å‹', 'development')
  .action(async (description, options) => {
    const vct = new VibeCodeTask();
    await vct.initialize();
    
    const task = await vct.addTask({
      name: description,
      requirements: description,
      priority: parseInt(options.priority),
      type: options.type
    });
    
    console.log(chalk.green(`âœ… å·²æ·»åŠ ä»»åŠ¡: ${task.name}`));
  });

program
  .command('list')
  .description('åˆ—å‡ºæ‰€æœ‰ä»»åŠ¡')
  .action(async () => {
    const vct = new VibeCodeTask();
    await vct.initialize();
    
    const tasks = vct.getAllTasks();
    
    if (tasks.length === 0) {
      console.log('æ²¡æœ‰ä»»åŠ¡');
      return;
    }
    
    console.log('\nğŸ“‹ ä»»åŠ¡åˆ—è¡¨:\n');
    
    tasks.forEach(task => {
      const status = task.status === 'completed' ? 'âœ…' :
                   task.status === 'running' ? 'ğŸ”„' :
                   task.status === 'failed' ? 'âŒ' : 'â³';
      
      console.log(`${status} [${task.priority}] ${task.name}`);
      console.log(`   ç±»å‹: ${task.type} | çŠ¶æ€: ${task.status}`);
      if (task.error) {
        console.log(chalk.red(`   é”™è¯¯: ${task.error}`));
      }
      console.log();
    });
  });

program
  .command('status')
  .description('æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€')
  .action(async () => {
    const vct = new VibeCodeTask();
    await vct.initialize();
    
    const stats = vct.getStats();
    const usage = await vct.checkUsage();
    
    console.log('\nğŸ“Š ç³»ç»ŸçŠ¶æ€:\n');
    console.log(`ä»»åŠ¡ç»Ÿè®¡:`);
    console.log(`  æ€»è®¡: ${stats.total}`);
    console.log(`  å¾…æ‰§è¡Œ: ${chalk.yellow(stats.pending)}`);
    console.log(`  è¿è¡Œä¸­: ${chalk.blue(stats.running)}`);
    console.log(`  å·²å®Œæˆ: ${chalk.green(stats.completed)}`);
    console.log(`  å¤±è´¥: ${chalk.red(stats.failed)}`);
    
    if (usage) {
      console.log(`\nClaude ä½¿ç”¨æƒ…å†µ:`);
      console.log(`  å‰©ä½™é¢åº¦: ${usage.remaining}/${usage.total} blocks`);
      console.log(`  ä½¿ç”¨ç‡: ${usage.percentageUsed}%`);
    }
  });

program
  .command('logs')
  .description('æ˜¾ç¤ºæ—¥å¿—')
  .option('-n, --lines <number>', 'æ˜¾ç¤ºè¡Œæ•°', 20)
  .action(async (options) => {
    const vct = new VibeCodeTask();
    await vct.showLogs(parseInt(options.lines));
  });

program
  .command('stop')
  .description('åœæ­¢è¿è¡Œ')
  .action(async () => {
    console.log('åœæ­¢ä»»åŠ¡ç®¡ç†å™¨...');
    process.exit(0);
  });

// é”™è¯¯å¤„ç†
process.on('unhandledRejection', (error) => {
  console.error(chalk.red('æœªå¤„ç†çš„é”™è¯¯:'), error);
  process.exit(1);
});

program.parse();
```

## 6. å®‰å…¨è€ƒè™‘

1. **æ•æ„Ÿä¿¡æ¯ä¿æŠ¤**
   - API å¯†é’¥ä½¿ç”¨ç¯å¢ƒå˜é‡
   - é…ç½®æ–‡ä»¶åŠ å¯†å­˜å‚¨
   - æ—¥å¿—è„±æ•å¤„ç†

2. **æƒé™æ§åˆ¶**
   - æœ€å°æƒé™åŸåˆ™
   - æ–‡ä»¶ç³»ç»Ÿéš”ç¦»
   - å‘½ä»¤æ³¨å…¥é˜²æŠ¤

3. **èµ„æºé™åˆ¶**
   - å†…å­˜ä½¿ç”¨é™åˆ¶
   - CPU ä½¿ç”¨é™åˆ¶
   - ç£ç›˜ç©ºé—´ç›‘æ§

## 7. æµ‹è¯•ç­–ç•¥

### 7.1 å•å…ƒæµ‹è¯•
- æ ¸å¿ƒæ¨¡å— 100% è¦†ç›–
- Mock Claude Code CLI
- æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µ

### 7.2 é›†æˆæµ‹è¯•
- ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•
- è°ƒåº¦å™¨å‹åŠ›æµ‹è¯•
- é”™è¯¯æ¢å¤æµ‹è¯•

### 7.3 æ€§èƒ½æµ‹è¯•
- å¤§é‡ä»»åŠ¡å¹¶å‘å¤„ç†
- å†…å­˜æ³„æ¼æ£€æµ‹
- å“åº”æ—¶é—´æµ‹è¯•

## 8. æœªæ¥æ‰©å±•

### 8.1 çŸ­æœŸè®¡åˆ’ï¼ˆ1-2 ä¸ªæœˆï¼‰
- Web ç®¡ç†ç•Œé¢
- ä»»åŠ¡æ¨¡æ¿ç³»ç»Ÿ
- æ›´å¤šè°ƒåº¦ç­–ç•¥

### 8.2 ä¸­æœŸè®¡åˆ’ï¼ˆ3-6 ä¸ªæœˆï¼‰
- Gemini CLI æ”¯æŒ
- å¤š AI åä½œ
- ä»»åŠ¡å¸‚åœº

### 8.3 é•¿æœŸè®¡åˆ’ï¼ˆ6+ ä¸ªæœˆï¼‰
- åˆ†å¸ƒå¼ä»»åŠ¡æ‰§è¡Œ
- AI è‡ªåŠ¨ä¼˜åŒ–
- ä¼ä¸šçº§åŠŸèƒ½

## 9. é£é™©ä¸å¯¹ç­–

| é£é™© | å½±å“ | å¯¹ç­– |
|------|------|------|
| Claude Code API å˜æ›´ | ç³»ç»Ÿæ— æ³•æ­£å¸¸è°ƒç”¨ | ç‰ˆæœ¬å…¼å®¹å±‚ï¼Œå¿«é€Ÿé€‚é… |
| é¢åº¦è€—å°½ | ä»»åŠ¡æ— æ³•æ‰§è¡Œ | æ™ºèƒ½è°ƒåº¦ï¼Œä¼˜å…ˆçº§ç®¡ç† |
| ä»»åŠ¡æ‰§è¡Œå¤±è´¥ | å½±å“åç»­ä»»åŠ¡ | é‡è¯•æœºåˆ¶ï¼Œä¾èµ–ç®¡ç† |
| ç³»ç»Ÿå´©æºƒ | ä»»åŠ¡çŠ¶æ€ä¸¢å¤± | çŠ¶æ€æŒä¹…åŒ–ï¼Œæ•…éšœæ¢å¤ |

## 10. æ€»ç»“

VibeCodeTask é€šè¿‡è‡ªåŠ¨åŒ–ä»»åŠ¡ç®¡ç†ã€æ™ºèƒ½è°ƒåº¦å’Œæç¤ºè¯ä¼˜åŒ–ï¼Œå®ç°äº† Claude Code çš„ 24 å°æ—¶é«˜æ•ˆåˆ©ç”¨ã€‚ç³»ç»Ÿè®¾è®¡è€ƒè™‘äº†å¯æ‰©å±•æ€§ã€ç¨³å®šæ€§å’Œæ˜“ç”¨æ€§ï¼Œä¸ºå¼€å‘è€…æä¾›äº†å¼ºå¤§çš„ AI è¾…åŠ©å¼€å‘å·¥å…·ã€‚