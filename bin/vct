#!/usr/bin/env node

/**
 * VibeCodeTask CLI å¯åŠ¨è„šæœ¬
 * è‡ªåŠ¨é€‰æ‹©æœ€ä½³å®ç°ç‰ˆæœ¬
 */

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

// æ£€æŸ¥å‘½ä»¤æ˜¯å¦å¯ç”¨
function commandExists(command) {
  try {
    require('child_process').execSync(`which ${command}`, { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

// è·å–å¯ç”¨çš„å®ç°
function getAvailableImplementations() {
  const implementations = [];
  
  // æ£€æŸ¥ Node.js ç‰ˆæœ¬
  if (fs.existsSync(path.join(__dirname, '..', 'src', 'index.js'))) {
    implementations.push({
      name: 'nodejs',
      command: 'node',
      script: path.join(__dirname, '..', 'src', 'index.js'),
      priority: 1
    });
  }
  
  // æ£€æŸ¥ Python ç‰ˆæœ¬
  const pythonScript = path.join(__dirname, '..', 'vct.py');
  if (fs.existsSync(pythonScript) && commandExists('python3')) {
    implementations.push({
      name: 'python',
      command: 'python3',
      script: pythonScript,
      priority: 2
    });
  }
  
  // æ£€æŸ¥ Shell ç‰ˆæœ¬
  const shellScript = path.join(__dirname, '..', 'vct.sh');
  if (fs.existsSync(shellScript)) {
    implementations.push({
      name: 'shell',
      command: 'bash',
      script: shellScript,
      priority: 3
    });
  }
  
  return implementations.sort((a, b) => a.priority - b.priority);
}

// æ‰§è¡Œæœ€ä½³å®ç°
function executeBestImplementation(args) {
  const implementations = getAvailableImplementations();
  
  if (implementations.length === 0) {
    console.error('âŒ æœªæ‰¾åˆ°å¯ç”¨çš„ VibeCodeTask å®ç°');
    console.error('è¯·ç¡®ä¿å·²æ­£ç¡®å®‰è£…é¡¹ç›®æ–‡ä»¶');
    process.exit(1);
  }
  
  const best = implementations[0];
  console.log(`ğŸš€ ä½¿ç”¨ ${best.name} å®ç°å¯åŠ¨ VibeCodeTask...`);
  
  // å¯åŠ¨å­è¿›ç¨‹
  const child = spawn(best.command, [best.script, ...args], {
    stdio: 'inherit',
    env: process.env
  });
  
  // å¤„ç†å­è¿›ç¨‹é€€å‡º
  child.on('close', (code) => {
    process.exit(code);
  });
  
  // å¤„ç†é”™è¯¯
  child.on('error', (error) => {
    console.error(`âŒ å¯åŠ¨å¤±è´¥: ${error.message}`);
    
    // å°è¯•ä¸‹ä¸€ä¸ªå®ç°
    if (implementations.length > 1) {
      console.log('å°è¯•å¤‡ç”¨å®ç°...');
      const fallback = implementations[1];
      
      const fallbackChild = spawn(fallback.command, [fallback.script, ...args], {
        stdio: 'inherit',
        env: process.env
      });
      
      fallbackChild.on('close', (code) => {
        process.exit(code);
      });
      
      fallbackChild.on('error', (fallbackError) => {
        console.error(`âŒ æ‰€æœ‰å®ç°å‡å¯åŠ¨å¤±è´¥`);
        console.error(`è¯·æ£€æŸ¥ç³»ç»Ÿä¾èµ–: node, python3, bash`);
        process.exit(1);
      });
    } else {
      process.exit(1);
    }
  });
}

// ä¸»ç¨‹åº
function main() {
  const args = process.argv.slice(2);
  
  // æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯
  if (args.includes('--version') || args.includes('-v')) {
    const packageJson = require('../package.json');
    console.log(`VibeCodeTask v${packageJson.version}`);
    return;
  }
  
  // æ˜¾ç¤ºç³»ç»Ÿä¿¡æ¯
  if (args.includes('--info')) {
    const implementations = getAvailableImplementations();
    console.log('ğŸ“Š ç³»ç»Ÿä¿¡æ¯:');
    console.log(`Node.js: ${process.version}`);
    console.log(`å¹³å°: ${process.platform}`);
    console.log(`æ¶æ„: ${process.arch}`);
    console.log('\nå¯ç”¨å®ç°:');
    implementations.forEach(impl => {
      console.log(`  âœ… ${impl.name} (${impl.command})`);
    });
    return;
  }
  
  executeBestImplementation(args);
}

// é”™è¯¯å¤„ç†
process.on('uncaughtException', (error) => {
  console.error('âŒ æœªæ•è·çš„å¼‚å¸¸:', error.message);
  process.exit(1);
});

process.on('unhandledRejection', (reason) => {
  console.error('âŒ æœªå¤„ç†çš„ Promise æ‹’ç»:', reason);
  process.exit(1);
});

// å¯åŠ¨
main();